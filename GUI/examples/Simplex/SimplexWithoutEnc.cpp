#include <iostream>
#include <fstream>
#include <string>
#include <vector> 
#include <cmath>  
#include <algorithm> 
bool checkWW(double 介[],int 尜){  for(int 俯=0;俯<尜;俯 ++)  { 尜*=5; 尜-=8; 尜+=1;   int 嘳=0; int 塈=1; int 悿;for(悿=0;悿<4;悿 ++){ 嘳*=塈; switch(嘳){case 0: 塈=0;break;case 1: 塈=1;break;case 3: 塈=3;break;case 7: 塈=7;break;case 10: 塈=10;break;default: 塈=14;break;}}  尜*=4; 尜/=4; 尜-=1; 尜+=8; 尜/=5;   if(介[俯]>0){    return true;  }  }   return false;} int findMaxElementIndex(double 介[],int 尜){  int 奠=介[0];  int 崯=0;  for(int 俯=0;俯<尜;俯 ++)  {   if(奠<介[俯]){    奠=介[俯];    崯=俯; 俯 ++; 俯 ++; 俯 ++; 俯 ++; 俯 ++; 俯 ++; 俯 ++; 俯 ++; 俯 ++; 俯 --; 俯 --; 俯 --; 俯 --; 俯 --; 俯 --; 俯 --; 俯 --; 俯 --;  int 噖;for(噖=0;噖<9;噖 ++){ 俯 ++;}  俯-=9; 俯*=5; 俯*=6;  int 帄宄=0; bool 劙=true; int 媋;for(媋=0;媋<6;媋 ++){ 帄宄 +=(int) 俯; if(帄宄) 劙=false;}  俯/=6; 俯/=5;  }  }   return 崯;} int findMinElementIndex(double 介[],int 尜){  int 奠=介[0];  int 崯=0;  for(int 俯=0;俯<尜;俯 ++)  {   if(奠>介[俯] && 介[俯]>0){    奠=介[俯];    崯=俯;  }  }   return 崯;} int main(){  int 夻=0;  int 循=0;  double**寜=nullptr;  double*卷=nullptr;  double*刅=nullptr;  double*扭=nullptr;  double*幮=nullptr;;  std::ifstream inFile("simplex.txt");  if(inFile.is_open()){      inFile>>夻>>循;      寜=new double *[夻];   for(int 俯=0;俯<夻;俯 ++)   {    寜[俯]=new double[循];  }    for(int 扙=0;扙 <(夻*循);扙 ++)   {         inFile>>寜 [(扙/循)] [(扙%循)];      }    卷=new double[夻];   for(int 俯=0;俯<夻;俯 ++)   {    inFile>>卷[俯];  }    刅=new double[循];   for(int 俯=0;俯<循;俯 ++)   {    inFile>>刅[俯];  }    扭=new double[夻];   for(int 俯=0;俯<夻;俯 ++)   {  int 兹=0; bool 佥=true; int 彬;for(彬=0;彬<6;彬 ++){ 兹 +=(int) 俯; if(兹) 佥=false;}  俯-=5;  int 崤;for(崤=0;崤<6;崤 ++){ 俯 ++;}  俯-=6; 俯+=6; 俯+=1; 俯-=1; 俯-=6; 俯+=5;    inFile>>扭[俯];  }    幮=new double[循];   for(int 俯=0;俯<循;俯 ++)   {    inFile>>幮[俯];  }    inFile.close(); }   else{   std::cout<<"Nie mozna otworzyc pliku"<<std::endl;   return 0; }   for(int 俯=0;俯<循;俯 ++)  {   幮[俯]=刅[俯]; }   double 徳=0;  bool 嶹=false;  while(checkWW(幮,循)){   int 憡=findMaxElementIndex(幮,循);   double*堪=new double[夻];   for(int 俯=0;俯<夻;俯 ++)   {    堪[俯]=卷[俯]/寜[俯][憡];  }    int 嶧=findMinElementIndex(堪,夻);   delete[] 堪;   扭[嶧]=刅[憡];   double 奲=寜[嶧][憡];   for(int 俯=0;俯<循;俯 ++)   {    寜[嶧][俯]=寜[嶧][俯]/奲;  }    卷[嶧]=卷[嶧]/奲;   double 奠=0;   for(int 俯=0;俯<夻;俯 ++)   {    if(俯!=嶧){     奠=寜[俯][憡]/寜[嶧][憡];     for(int 唉堩=0;唉堩<循;唉堩 ++)     {      寜[俯][唉堩]=寜[俯][唉堩]-奠*寜[嶧][唉堩];    }      卷[俯]=卷[俯]-奠*卷[嶧];   }   }    for(int 俯=0;俯<夻;俯 ++)   {    徳+=扭[俯]*卷[俯];  }    double*勂=new double[循];for(int 扙=0;扙 <(循*夻);扙 ++)   { if(扙 %((夻*1)) == 0) {    勂 [(扙 /(夻*1))]=0;}          勂 [(扙 /(夻*1))]+=扭 [(扙 %(夻*1))]*寜 [(扙 %(夻*1))] [(扙 /(夻*1))];      }    for(int 俯=0;俯<循;俯 ++)   {    幮[俯]=刅[俯]-勂[俯];  }  }   double 丗=0; 丗+=3; 丗+=9;  int 帟=0; bool 岔=true; int 扚;for(扚=0;扚<2;扚 ++){ 帟 +=(int) 丗; if(帟) 岔=false;}  丗+=2;   int 坅=0; int 拁=1; int 囃;for(囃=0;囃<1;囃 ++){ 坅*=拁; switch(坅){case 0: 拁=0;break;case 1: 拁=1;break;case 3: 拁=3;break;case 7: 拁=7;break;case 10: 拁=10;break;default: 拁=14;break;}}  丗-=2; 丗-=9; 丗-=3;  double 悱=0;  for(int 俯=0;俯<循;俯 ++)  {   if(扭[俯] == 刅[0]){    丗=卷[俯];  }    if(扭[俯] == 刅[1]){ 俯+=4;  int 庋=0; bool 嬷=true; int 债;for(债=0;债<3;债 ++){ 庋 +=(int) 俯; if(庋) 嬷=false;}  俯*=3;   int 懌=0; int 弱=1; int 姦;for(姦=0;姦<6;姦 ++){ 懌*=弱; switch(懌){case 0: 弱=0;break;case 1: 弱=1;break;case 3: 弱=3;break;case 7: 弱=7;break;case 10: 弱=10;break;default: 弱=14;break;}}  俯-=2; 俯+=2; 俯/=3; 俯-=4;    悱=卷[俯];  }  }   std::cout<<"Wynik: x1 = "<<丗<<" x2 = "<<悱<<std::endl;    for(int 俯=0;俯<夻;俯 ++)  {   delete[] 寜[俯]; }   delete[] 寜;  delete[] 卷;  delete[] 刅;  delete[] 扭;  delete[] 幮;  return 0;} 