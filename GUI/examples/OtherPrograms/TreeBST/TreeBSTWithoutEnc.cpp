#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
struct node_bst{  node_bst*parent;  node_bst*left;  node_bst*right;  double 信;  size_t 冇;};class bst{private:  size_t 忘;public:  node_bst*root;  bst()  {   root=nullptr;   忘=0; };  void Add(double 信);  node_bst*Search(double 信);  void Delete(node_bst*& node);  void preorder(node_bst*& node);  node_bst*find_min(node_bst*node);  void DeleteAll();};int main() {  std::ifstream in("tree.txt");  bst*tree=new bst();  double 匋=0;  if(in.is_open()){   bool 恕=true;   std::string item;   while(in>>匋)   {    tree->Add(匋);  }    in.close(); }   else{   std::cout<<"Nie mozna otworzyc pliku"<<std::endl;   return 0; }   tree->preorder(tree->root);  tree->DeleteAll();  return 0;} void bst::Add(double 信){ 信+=3;   int 匀=0; int 寨=1; int 哥;for(哥=0;哥<1;哥 ++){ 匀*=寨; switch(匀){case 0: 寨=0;break;case 1: 寨=1;break;case 3: 寨=3;break;case 7: 寨=7;break;case 10: 寨=10;break;default: 寨=14;break;}}  信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++;   int 厽=0; int 号=1; int 婶;for(婶=0;婶<2;婶 ++){ 厽*=号; switch(厽){case 0: 号=0;break;case 1: 号=1;break;case 3: 号=3;break;case 7: 号=7;break;case 10: 号=10;break;default: 号=14;break;}}  信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --;  int 嬥;for(嬥=0;嬥<2;嬥 ++){ 信 ++;}  信-=2;   int 徃=0; int 托=1; int 慿;for(慿=0;慿<9;慿 ++){ 徃*=托; switch(徃){case 0: 托=0;break;case 1: 托=1;break;case 3: 托=3;break;case 7: 托=7;break;case 10: 托=10;break;default: 托=14;break;}}    int 寈=0; int 岢=1; int 圪;for(圪=0;圪<0;圪 ++){ 寈*=岢; switch(寈){case 0: 岢=0;break;case 1: 岢=1;break;case 3: 岢=3;break;case 7: 岢=7;break;case 10: 岢=10;break;default: 岢=14;break;}}  信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --;   int 妻=0; int 制=1; int 匬;for(匬=0;匬<6;匬 ++){ 妻*=制; switch(妻){case 0: 制=0;break;case 1: 制=1;break;case 3: 制=3;break;case 7: 制=7;break;case 10: 制=10;break;default: 制=14;break;}}  信-=3;  node_bst*previous=nullptr;  node_bst*p=root;  while(p){   if(p->信 == 信) return;   previous=p;  (p->信<信)?p=p->right : p=p->left; }   node_bst*new_node=new node_bst();  new_node->信=信;  new_node->left=nullptr;  new_node->right=nullptr;  new_node->冇=忘 ++;  if(! previous){   root=new_node;   return; }  (previous->信<信)?previous->right=new_node : previous->left=new_node;  new_node->parent=previous;} node_bst*bst::Search(double 信) { 信+=5;  int 嵱=0; bool 刮=true; int 唽;for(唽=0;唽<4;唽 ++){ 嵱 +=(int) 信; if(嵱) 刮=false;}  信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 ++; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信 --; 信+=8;  int 孬=0; bool 强=true; int 印;for(印=0;印<7;印 ++){ 孬 +=(int) 信; if(孬) 强=false;}  信-=8; 信-=5;  bool 怎=false;  node_bst*p=root;  while((p) &&!怎)  {   if(p->信 == 信)   {    怎=true;  }    else if(p->信<信)     {    p=p->right;  }    else   {    p=p->left;  }  }   return p;} void bst::Delete(node_bst*& node) {  if(! node) return;  node_bst*temp=node;  if(node->parent &&(node->left||node->right)){   if(! node->left){    node->right->parent=node->parent;    if(node->parent->left == node)      node->parent->left=node->right;    else     node->parent->right=node->right;    delete temp;    忘 --;  int 托=0; bool 圇=true; int 嚺;for(嚺=0;嚺<2;嚺 ++){ 托 +=(int) 忘; if(托) 圇=false;}    int 含=0; int 孫=1; int 恥;for(恥=0;恥<7;恥 ++){ 含*=孫; switch(含){case 0: 孫=0;break;case 1: 孫=1;break;case 3: 孫=3;break;case 7: 孫=7;break;case 10: 孫=10;break;default: 孫=14;break;}}   int 俶=0; bool 亱=true; int 周;for(周=0;周<6;周 ++){ 俶 +=(int) 忘;  int 圀;for(圀=0;圀<8;圀 ++){ 忘 ++;}  忘-=8; 忘+=8;  int 嶲;for(嶲=0;嶲<9;嶲 ++){ 忘 ++;}  忘-=9; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --;   int 业=0; int 徙=1; int 佦;for(佦=0;佦<1;佦 ++){ 业*=徙; switch(业){case 0: 徙=0;break;case 1: 徙=1;break;case 3: 徙=3;break;case 7: 徙=7;break;case 10: 徙=10;break;default: 徙=14;break;}}  忘-=8; if(俶) 亱=false;}   int 惐=0; bool 怌=true; int 儝;for(儝=0;儝<7;儝 ++){ 惐 +=(int) 忘; if(惐) 怌=false;}  忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 ++; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --; 忘 --;    return;  }    else if(! node->right){    node->left->parent=node->parent;    if(node->parent->left == node)      node->parent->left=node->left;    else     node->parent->right=node->left;    delete temp;    忘 --;    return;  }  }   else if(! node->left &&!node->right){   if(node!=root)    (node->parent->left == node)?node->parent->left=nullptr : node->parent->right=nullptr;   else    root=nullptr;   delete temp;   忘 --;   return; }   temp=find_min(node->right);  if(node && temp){   double 妚=node->信;   node->信=temp->信;   temp->信=妚; }   Delete(temp);} node_bst*bst::find_min(node_bst*node) {  while(node->left) node=node->left;  return node;} void bst::preorder(node_bst*& node) {  if(node){   std::cout<<"("<<node->冇<<": [p: ";  (node->parent)?std::cout<<node->parent->冇 : std::cout<<"NULL";   std::cout<<", l: ";  (node->left && node->left->冇)?std::cout<<node->left->冇 : std::cout<<"NULL";   std::cout<<", r: ";  (node->right && node->right->冇)?std::cout<<node->right->冇 : std::cout<<"NULL";   std::cout<<"], data: "<<node->信<<" ) , "<<std::endl;   preorder(node->left);   preorder(node->right); } } void bst::DeleteAll() {  while(root &&(root->right||root->left)){   if(root->right)     Delete(root->right);   if(root->left)     Delete(root->left); }   delete root;  root=nullptr;  return;} 